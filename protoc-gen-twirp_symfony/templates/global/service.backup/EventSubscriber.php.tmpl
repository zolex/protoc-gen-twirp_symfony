<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT! (protoc-gen-twirp_symfony 0.8.1)
# source: UselessService.proto

declare(strict_types=1);

namespace {{ .File | phpNamespace }};

use Google\Protobuf\Internal\Message;
use Modix\TwirpBundle\Twirp\AbstractServiceHandler;
use Modix\TwirpBundle\Twirp\ServiceHandlerInterface;

/**
 * @see {{ .Service | phpServiceName .File }}
 *
 * Generated from protobuf service <code>{{ .Service.Desc.Name }}</code>
 */
final class {{ .Service | phpServiceName .File }}EventSubscriber extends AbstractServiceHandler implements ServiceHandlerInterface
{
    public function __construct(
        private readonly {{ .Service | phpServiceName .File }}Interface $service,
        protected readonly string $prefix = '/twirp',
        protected readonly ?string $packageName = '{{ .File.Proto.GetPackage }}',
        protected readonly string $serviceName = '{{ .Service.Desc.Name }}'
    ) {
    }

    public function inputMessageFactory(array $ctx): ?Message
    {
        switch ($ctx['method_name']) {
{{- range $method := .Service.Methods }}
    {{- $inputType := $method.Input | phpMessageName $.File }}
            case '{{ $method | protoMethodShortName }}':
                return new {{ $inputType }}();
{{- end }}
            default:
                return null;
        }
    }

    protected function callMethod(array $ctx, Message $input): ?Message
    {
        switch ($ctx['method_name']) {
{{ range $method := .Service.Methods }}
        {{- $inputType := $method.Input | phpMessageName $.File }}
            case '{{ $method | protoMethodShortName }}':
                return $this->service->{{ $method | protoMethodShortName }}($ctx, $input);
{{- end }}
            default:
                return null;
        }
    }
}
